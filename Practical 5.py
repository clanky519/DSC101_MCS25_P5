# -*- coding: utf-8 -*-
"""prac_5_bpt.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OKJNZcEFhMmHyh7LgvHZBmAEKIivp_Lt
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import random
import time
import math
from sklearn.datasets import load_iris, load_wine, load_breast_cancer, load_digits, load_diabetes

def euclidean(a, b):
    if len(a) != len(b):
        raise ValueError("Points must have the same dimension")
    a = np.array(a)
    b = np.array(b)
    return np.linalg.norm(a - b)

def is_feasible(points, k, radius):
  points = np.array(points)
  n = len(points)

  centers = []
  covered = np.zeros(n, dtype=bool)

  for i in range(n):
    if not covered[i]:
      centers.append(points[i])

      for j in range(n):
        if euclidean(points[i], points[j]) <= radius:
          covered[j] = True

  return len(centers) <= k, centers

def branch_n_bound_kcenter(points, k, epsilon=1e-5):
  points = np.array(points)
  n = len(points)

  distances = [euclidean(points[i], points[j]) for i in range(n) for j in range(i+1, n)]

  d_min = min(distances)
  d_max = max(distances)

  low, high = d_min, d_max

  # Binary search on radius R
  while high - low > epsilon:
    mid = (low + high) / 2
    feasible, _ = is_feasible(points, k, mid)

    if feasible:
      high = mid
    else:
      low = mid

  feasible, centers = is_feasible(points, k, high)

  return np.array(centers), high

# Gonzalez is also known as Random Farthest First methos (A greedy approach)
def gonzalez_kcenter(points, k):
  points = np.array(points)
  n = len(points)

  first_index = random.randint(0, n-1)
  centers = [points[first_index]]

  for _ in range(1, k):
    distances = np.array([min(euclidean(p, c) for c in centers) for p in points])

    farthest = np.argmax(distances)
    centers.append(points[farthest])

  final_distances = np.array([min(euclidean(p, c) for c in centers) for p in points])

  radius = np.max(final_distances)

  return np.array(centers), radius

def closest_center(points, centers, max_radius):
    points = np.array(points)
    centers = np.array(centers)

    center_point_relation = []

    for p in points:
        # Compute all Euclidean distances at once
        dists = np.linalg.norm(centers - p, axis=1)
        min_idx = np.argmin(dists)
        min_dist = dists[min_idx]

        if min_dist <= max_radius:
            center_point_relation.append((tuple(p), tuple(centers[min_idx])))

    # Unique centers (convert tuples)
    unique_centers = {c for _, c in center_point_relation}

    return center_point_relation, list(unique_centers)

def plot_kcenter(points, centers, r, title="K-Center Plot", labelX="X", labelY="Y"):

    colours = [
        "red", "green", "blue", "yellow", "orange",
        "lightsteelblue", "brown", "purple", "darksalmon",
        "teal", "black", "pink", "cyan"
    ]

    points = np.array(points)
    centers = np.array(centers)

    # print(f"Point: {points[5]} and Center: {centers[5]}")
    # print(f"Point: {len(points[5])} and Center: {len(centers[5])}")

    # print(f"Number of points before: {len(points)}")
    # print(f"Number of centers before: {len(centers)}")

    relations, used_centers = closest_center(points, centers, r)

    # print(f"Relations: {relations[5]} and Centers: {used_centers[5]}")
    # print(f"Relations: {len(relations[5])} and Centers: {len(used_centers[5])}")


    used_centers_set = {tuple(uc) for uc in used_centers}
    cts = np.array(used_centers)

    pts = np.array([p for (p, _) in relations if tuple(p) not in used_centers_set])


    # print(f"Number of points after: {len(pts)}")
    # print(f"Number of centers after: {len(cts)}")


    center_index = {tuple(c): i for i, c in enumerate(cts)}

    colors_for_points = [colours[center_index[c]] for (p, c) in relations if tuple(p) not in used_centers_set]


    plt.figure(figsize=(10, 10))

    plt.scatter(pts[:, 0], pts[:, 1], c=colors_for_points, marker="o")
    plt.scatter(cts[:, 0], cts[:, 1], color='black', s=150, marker="x", label="Centers")

    plt.title(title)
    plt.xlabel(labelX)
    plt.ylabel(labelY)
    plt.grid(True)
    plt.show()

points = []

for i in range(25):
  for j in range(25):
    points.append((random.randint(0, 25), random.randint(0, 25)))

# points

cg, cg_cost = gonzalez_kcenter(points, 9)

plot_kcenter(points, cg, cg_cost, title="Gonzalez K-Center Plot on Toy Dataset")

chs, chs_cost = branch_n_bound_kcenter(points, 9)

plot_kcenter(points, chs, chs_cost, title="Hochbaum Shmoys K-Center")

k = [3, 6, 9]
results = []
method = None
dataset = None

"""# Iris Dataset"""

iris_points = load_iris().data
dataset = "Iris"

method = "Gonzalez"
for i in range(len(k)):
  start = time.time()
  iris_gonzalez, iris_gonzalez_cost = gonzalez_kcenter(iris_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], iris_gonzalez_cost, runtime))

method = "Branch and Bound"
for i in range(len(k)):
  start = time.time()
  iris_bnb, iris_bnb_cost = branch_n_bound_kcenter(iris_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], iris_bnb_cost, runtime))

"""# Wine Dataset"""

wine_points = load_wine().data
dataset = "Wine"

method = "Gonzalez"
for i in range(len(k)):
  start = time.time()
  wine_gonzalez, wine_gonzalez_cost = gonzalez_kcenter(wine_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], wine_gonzalez_cost, runtime))

method = "Branch and Bound"
for i in range(len(k)):
  start = time.time()
  wine_bnb, wine_bnb_cost = branch_n_bound_kcenter(wine_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], wine_bnb_cost, runtime))

"""# Breast Cancer"""

bc_points = load_breast_cancer().data
dataset = "Breast Cancer"

method = "Gonzalez"
for i in range(len(k)):
  start = time.time()
  bc_gonzalez, bc_gonzalez_cost = gonzalez_kcenter(bc_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], bc_gonzalez_cost, runtime))

method = "Branch and Bound"
for i in range(len(k)):
  start = time.time()
  bc_bnb, bc_bnb_cost = branch_n_bound_kcenter(bc_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], bc_bnb_cost, runtime))

"""# MNIST Dataset"""

mnist_points = load_digits().data
dataset = "MNIST Digits (8X8)"

method = "Gonzalez"
for i in range(len(k)):
  start = time.time()
  mnist_gonzalez, mnist_gonzalez_cost = gonzalez_kcenter(mnist_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], mnist_gonzalez_cost, runtime))

method = "Branch and Bound"
for i in range(len(k)):
  start = time.time()
  mnist_bnb, mnist_bnb_cost = branch_n_bound_kcenter(mnist_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], mnist_bnb_cost, runtime))

"""# Diabetes Dataset"""

diabetes_points = load_diabetes().data
dataset = "Diabetes"

method = "Gonzalez"
for i in range(len(k)):
  start = time.time()
  diabetes_gonzalez, diabetes_gonzalez_cost = gonzalez_kcenter(diabetes_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], diabetes_gonzalez_cost, runtime))

method = "Branch and Bound"
for i in range(len(k)):
  start = time.time()
  diabetes_bnb, diabetes_bnb_cost = branch_n_bound_kcenter(diabetes_points, k[i])
  runtime = time.time() - start
  results.append((method, dataset,k[i], diabetes_bnb_cost, runtime))

df = pd.DataFrame(results, columns=["Method Used", "Dataset Used", "k", "Cost", "Runtime (ms)"])
df.to_csv("results.csv", index=False)

df